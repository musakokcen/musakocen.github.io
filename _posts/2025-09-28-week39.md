---
layout: blogpost
title: "Week #39: Exploring Unit Testing in Flutter"
subtitle: ""
---

I spent some time exploring unit tests in Flutter this week. I picked a repository with important tasks and related models and then started to discover the testing framework. The learning curve was actually pretty low, and once I grasped the basics, the rest came quickly.

Beyond the most basics. A third-party package, "Mockito", is useful for mocking dependencies and isolating your testing unit. Mocked dependencies are very flexible. You can set return values for their functions or manipulate streams. While reviewing example tests online, I came across the "verify()" method, which ensures that a function in the tested unit is actually called, thus preventing lucky passes.

While working on my unit tests, I found some couplings and a few weak logic points and fixed them. I kept my changes as small as possible and didn't go beyond the test's purpose. This made the changes in the pull request easily relatable to the test. Even with careful coding and peer reviews, some issues can still go unnoticed. This showed me just how valuable testing is, and that the time spent on it is rewarding.

 